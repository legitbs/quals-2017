#!/usr/bin/python
import sys
import argparse
import socket
import select
import string
import io
import struct
import string
import random
import time
import hashlib
import sla_conf
import random
import signal
import os
import time
import subprocess

def randbytes(n):
    for _ in xrange(n):
        yield random.getrandbits(8)

def rc4_init( key, dropAmount ):
	j = 0
	t = 0
	box = range( 256 )

	for i in range( 256 ):
		j = (j + box[i] + ord(key[i % len(key)])) % 256
		t = box[i]
		box[i] = box[j]
		box[j] = t

	i += 1	
	x = 0
	for x in range( dropAmount ):
		i = (i + 1) % 256
		j = (j + box[i]) % 256
		t = box[i]
		box[i] = box[j]
		box[j] = t

	return box	

def rc4_encrypt( box, data, size ):
	i = 0
	j = 0

	out = []	
	for x in range( size ):
		i = (i + 1) % 256
		j = (j + box[i]) % 256
		box[i], box[j] = box[j], box[i]
		out.append(chr(ord(data[x]) ^ box[(box[i] + box[j]) % 256]))

	return ''.join(out)	

def rand_string(size=6, chars=string.ascii_uppercase + string.digits):
	return ''.join(random.choice(chars) for x in range(size))

def rand_allstring(size=6, chars=string.ascii_uppercase + string.ascii_lowercase + string.digits):
	return ''.join(random.choice(chars) for x in range(size))

def recv_until(s, datalen):
	total_data=[]
	pos = 0
	while True:
		if ( pos >= datalen ):
			break 

		data = s.recv(1)

		if not data:
			break	
	
		total_data.append(data)
		pos = pos + 1

	return ''.join(total_data)



#assume a socket disconnect (data returned is empty string) means  all data was #done being sent.
def recv_basic(the_socket):
    total_data=[]
    while True:
        data = the_socket.recv(8192)
        if not data: break
        total_data.append(data)
    return ''.join(total_data)
    
def recv_timeout(the_socket,timeout=2):
    the_socket.setblocking(0)
    total_data=[];data='';begin=time.time()
    while 1:
        #if you got some data, then break after wait sec
        if total_data and time.time()-begin>timeout:
            break
        #if you got no data at all, wait a little longer
        elif time.time()-begin>timeout*2:
            break
        try:
            data=the_socket.recv(8192)
            if data:
                total_data.append(data)
                begin=time.time()
            else:
                time.sleep(0.1)
        except:
            pass
    return ''.join(total_data)

End='\n'
def recv_end(the_socket):
    total_data=[];data=''
    while True:
            data=the_socket.recv(8192)
            if End in data:
                total_data.append(data[:data.find(End)])
                break
	    print('Got %s\n' % data)
            total_data.append(data)
            if len(total_data)>1:
                #check if end_of_data was split
                last_pair=total_data[-2]+total_data[-1]
                if End in last_pair:
                    total_data[-2]=last_pair[:last_pair.find(End)]
                    total_data.pop()
                    break
    return ''.join(total_data)

def recv_size(the_socket):
    #data length is packed into 4 bytes
    total_len=0;total_data=[];size=sys.maxint
    size_data=sock_data='';recv_size=8192
    while total_len<size:
        sock_data=the_socket.recv(recv_size)
        if not total_data:
            if len(sock_data)>4:
                size_data+=sock_data
                size=struct.unpack('>i', size_data[:4])[0]
                recv_size=size
                if recv_size>524288:recv_size=524288
                total_data.append(size_data[4:])
            else:
                size_data+=sock_data
        else:
            total_data.append(sock_data)
        total_len=sum([len(i) for i in total_data ])
    return ''.join(total_data)

def is_ip_addr(string):
        try:
                socket.inet_aton(string)
        except socket.error:
                raise argparse.ArgumentTypeError("%s is not a valid IP address" % string)
        return string



def send_exec( fileName, ip_addr, port ):
	try:
		curFile = io.FileIO( fileName )

        	fileData = curFile.readall()

        	curFile.close()

        except IOError, e:
                print('Error opening local file "%s"' % fileName )
                exit(1)

	try:
		s = socket.socket( socket.AF_INET, socket.SOCK_STREAM )

		# 20 second timeout
		#s.settimeout( 30.0 )

		s.connect( (ip_addr, port) )

		packed_size = struct.pack("i", len(fileData))
	
		s.sendall( packed_size )
		s.sendall( fileData )

		print ('Now waiting for <<RUNNING>>\n')
		# now wait until we get a <<RUNNING>> message
		data = recv_end(s)	
		
		if ( data == '<<RUNNING>>' ):
			# return connection to use
			return s
		else:
			print('Failed did not receive <<RUNNING>>\n')
			exit(1)

	except IOError, e:
		print('Error connecting: %s\n' % e)
		exit(1)
	

		
def sla_echo( ip_addr, port ):

	try:
		s = send_exec( 'test_echo.meb', ip_addr, port )

		rand_strings = (rand_string( random.randint( 5, 20 ) ) for x in range( random.randint( 2, 7 ) ))
		
		for x in rand_strings:	
			time.sleep(0.5)
			
			print "Sending %s\n" % x

			out_str = x + '\n'	
			s.sendall( out_str )

			recvString = ''


			recvData = s.recv( 4096 )

			recvString += recvData

			if ( recvString == x ):
				print "Got %s\n" % recvString
				break
			else:
				print "Bad match %s\n" % recvString
				exit(1)

	
	except IOError, e:
		print('Error connecting: %s\n' % e)
		print('Recv: %s\n' % recvString )
		exit(1)

	print "Success!\n"
	exit(0)

def sla_sha256( ip_addr, port ):

	m = hashlib.sha256()
	try:
		s = send_exec( 'test_sha.meb', ip_addr, port )

		rand_strings = (rand_allstring( random.randint( 5, 25 ) ) for x in range( random.randint( 3, 6 ) ))
		
		for x in rand_strings:	
			time.sleep(.5)
			
			print "Sending %s\n" % x

			m.update( x )
			out_str = x + '\n'	
			s.sendall( out_str )

		s.sendall( ">>END>>\n" )

		hash_str = recv_end(s)	

		if ( hash_str != m.hexdigest() ):
			print "Bad hash %s\n" % hash_str
			exit(1)

	
	except IOError, e:
		print('Error connecting: %s\n' % e)
		exit(1)

	print "Success!\n"
	exit(0)
	
def sla_rc4( ip_addr, port ):

	try:
		s = send_exec( 'test_rc4.meb', ip_addr, port )

		rand_strings = (rand_allstring( random.randint( 5, 120 ) ) for x in range( random.randint( 3, 7 ) ))
	
		key = "Not a strong key"
		
		rc4_state = rc4_init( key, 256 )
	
		for x in rand_strings:	
			time.sleep(0.5)
			
			print "Sending %s\n" % x
			packed_size = struct.pack("i", long(len(x)))
			
			s.sendall( packed_size )
			s.sendall( x )

			check_data = rc4_encrypt( rc4_state, x, len(x) )

			# Receive
			recv_string = recv_until(s, len(x))


			if ( check_data != recv_string ):
				print "%x\n" % recv_string		
				print "%x\n" % check_data
				print "Bad match!"
				exit(1)
	
		packed_size = struct.pack("i", long(0))
		s.sendall( packed_size )

	
	except IOError, e:
		print('Error connecting: %s\n' % e)
		exit(1)

	print "Success\n"
	exit(0)

def sla_lzss( ip_addr, port ):
	fileName = ip_addr
	random.seed()
	r = random.randint(1000,2000)
	randfile = open(fileName + ".in","w")
	for i in randbytes(r):
		randfile.write(chr(i))
	randfile.close()
	subprocess.call(["./lzss", "e", fileName + ".in", fileName + ".out"])

	curFile = open(fileName + ".out","r")
	fileData = curFile.read()
	curFile.close()


	
	try:
		s = send_exec( 'test_lzss.meb', ip_addr, port )

		packed_size = struct.pack("i", long(len(fileData)))

		print "Sending %d bytes." % len(fileData)
		# Send file	
		s.sendall( packed_size )
		s.sendall( fileData )
		
		recv_string = recv_until(s, 4)

		dataLen = struct.unpack("i", recv_string)[0]	
		
		print "Data Length: %d\n" % dataLen

		recv_string = recv_until(s, long(dataLen))

		if (recv_string == open(fileName + ".in","r").read()):
			print "Success!"
			retval = 0 
		else:
			print "Fail!"
			retval = 1
			
		end_str = struct.pack("i", long(0))
		s.sendall( end_str ) 		
		exit (retval)
		
	except IOError, e:
		print('Error connecting: %s\n' % e)
		exit(1)

	exit(0)


if __name__ == '__main__':
	parser = argparse.ArgumentParser( description="This script runs SLA checks on a REESES server",
        epilog='''\
        Example:
                sla_noexploit.py <ip address>''', usage="%(prog)s [-p port] ipaddr",
        formatter_class = argparse.RawDescriptionHelpFormatter)

	parser.add_argument('-p', type=int, dest='remote_port', help="Port of service", default=3456)
        parser.add_argument('ip_addr', type=is_ip_addr, help="IP address")

        if len (sys.argv)<2:
                parser.print_help()
                exit(1)
	
	args = parser.parse_args()
	signal.alarm(sla_conf.timeout)
	random.seed()
	func = sla_conf.slaList[random.randint(0,len(sla_conf.slaList)-1)]
	print func
	func( args.ip_addr, args.remote_port )
	

